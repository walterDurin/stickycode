#summary A short guide to get you started with Mockwire

= Introduction =

Mockwire is a tool to provide isolated test contexts.

Ideally we would always test our code just as it gets wired in production, if we write boiler plate code in our tests and use dependency injection in production environments we are really testing out code correctly.

One possible solution is to use di contexts for integration and functional testing, however it soon becomes unwieldy to maintain, 1000s of lines of xml for spring quickly becomes more complicated that the software you are building.

Using classpath scanning for components and jsr330 you can run you tests environments just like the production wiring would.

If you have used MockitoAnnotations.initMocks then Mockwire will make perfect sense to you.

= To use Mockwire with Junit =

Just use the junit4 [http://code.google.com/p/stickycode/source/browse/trunk/net.stickycode.mockwire/sticky-mockwire/src/main/java/net/stickycode/mockwire/junit4/MockwireRunner.java MockwireRunner] to execute the test in a Mockwire context.

{{{
@RunWith(MockwireRunner.class)
public class UnitTest {
}}}

= Blessing and Mocking (or perhaps Mocking and Wiring) =

Essentially Mockwire turns a test class into the manifest for a bean context aka Spring ApplicationContext or a Guice injector.

It does this with two annotations @Bless and @Mock.

Mockwire scans the test classes and identitifies the code you wish to test, e.g.
{{{
@Bless
SomeConcreteClass codeToTest;
}}}
And controlled dependencies of the code to test, e.g.
{{{
@Mock
SomeInterface thatSomeConcreteClassNeeds;
}}}

= Example unit test =

{{{
@RunWith(MockwireRunner.class)
public class UnitTest {

  /**
   * A unit of code to be tested
   */
  static class Unit {
    public boolean echo(boolean echo) {
      return echo;
    }
  }

  @Bless
  Unit unit;

  @Test
  public void simple() {
    assertThat(unit).isNotNull();
    assertThat(unit.echo(true)).isTrue();
    assertThat(unit.echo(false)).isFalse();
  }
}}}
