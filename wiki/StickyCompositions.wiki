#summary Managing the lifecycles of third party libraries

= Introduction =

When you have more than one deliverable e.g. two wars, you will most likely end up with a scenario where they share libraries in common. Consider a logging implementation as a good example.

== The logging implementation dependency ==

All my wars have a logback-X.Y.X.jar in them. I could specify the version in each of the war projects however given that the lifecycles of the war projects are most likely not in sync I want to learn from what works with one when moving onto the next.

So I compose the logging implementation into its own project with its own version. Now I have my-logging-implementation-N.M. where N.M is an internal version not related to logback, I don't really care as the versions are meaningless in every respect *except* I assert that every my-logging-implementation-N.* will be compatible.

No if each of my wars depends upon my-logging-implementation-N.* I can easily inject a new version of the logging implementation into a continous integration environment to see if anything breaks when ever the upstream library changes.

== Continuous integration to validate new upstream ==
